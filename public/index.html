<!DOCTYPE html>
<html>
<head>
    <title>Teyvat Map</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta property="og:title" content="Teyvat Map">
    <meta property="og:description" content="Interactive 3D map of Teyvat from Genshin Impact with dynamic LOD streaming">
    <meta property="og:image" content="https://hoyomap.vercel.app/thmb.jpg">
    <meta property="og:url" content="https://hoyomap.vercel.app">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Teyvat Map">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Teyvat Map">
    <meta name="twitter:description" content="Interactive 3D map of Teyvat from Genshin Impact with dynamic LOD streaming">
    <meta name="twitter:image" content="https://hoyomap.vercel.app/thmb.jpg">
    
    <link rel="icon" type="image/png" href="https://cdn.flatypus.me/genshin/favicon.png">
    <style>
        body { margin: 0; overflow: hidden; background: #0a0a0f; }
        canvas { display: block; }
        #hud {
            position: absolute; top: 10px; left: 10px;
            color: #7ee787; font-family: 'JetBrains Mono', monospace; font-size: 13px;
            background: rgba(0,0,0,0.7); padding: 12px 16px; border-radius: 8px;
            border: 1px solid #30363d; min-width: 200px;
            user-select: none;
        }
        #hud .header { display: flex; align-items: center; gap: 8px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid #30363d; }
        #hud .header a { display: flex; align-items: center; gap: 8px; text-decoration: none; }
        #hud .header img { width: 20px; height: 20px; }
        #hud .header h1 { margin: 0; font-size: 18px; font-weight: 600; color: #ffffff; }
        #hud .l { color: #8b949e; }
        #hud .v { color: #58a6ff; }
        #hud .o { color: #f0883e; }
        #hud .row { padding-left: 12px; }
        #hud .section { margin-top: 8px; }
        #hud .toggles { margin-top: 8px; font-size: 11px; color: #666; }
        #hud .on  { color: #7ee787; }
        #hud .off { color: #f85149; }
        #hud .walk-panel {
            margin-top: 4px; padding: 4px; background: #1a4a1a;
            border-radius: 3px; font-size: 11px;
        }
        #hud .legend { margin-top: 4px; font-size: 10px; }
    </style>
</head>
<body>
    <div id="hud"></div>

    <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.157.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/" } }
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    const IS_PROD = true;
    const PATH = IS_PROD ? 'https://cdn.flatypus.me/genshin' : 'http://127.0.0.1:8080';
    const GAME_DATA = `${PATH}/game_data`;
    const BASE = PATH;

    const BLOCK_SIZE = 1024;
    const HALF_BLOCK = 512;
    const LOD_UPDATE_MS = 500;

    const HLOD_THRESHOLDS = [12000, 22000]; // [Lod0 max, Lod1 max]; beyond = Lod2
    const TERRAIN_THRESHOLD = 6000;
    const CITY_SOUTH_OFFSET = BLOCK_SIZE;

    const WALK_BASE_SPEED = 200;
    const WALK_MIN_MULT = 1;
    const WALK_MAX_MULT = 200;
    const WALK_DEFAULT_MULT = 100;
    const WALK_HEIGHT = 50;

    const MAX_ASSET_LOAD_COUNT = 20;
    const MAX_RETRIES = 3;

    const DEBUG_COLORS = {
        hlod_0: 0xff0000,    hlod_1: 0xff6600,    hlod_2: 0xffcc00,
        terrain_0: 0x00ff00, terrain_1: 0x00ffff,  terrain_2: 0x0066ff,
        water: 0x0088ff,
        city_0: 0xff00ff,    city_1: 0xcc00cc,     city_2: 0x990099,
    };

    const REGION_PATTERNS = [
        [/Mengde/i,                                                          null, true],
        [/LY|Ly_|LYG|Liyue|GL_|GLYJ|HC_/i,                                 0xE8D4B8],
        [/DQ|Dq_|HZD|Inazuma/i,                                             0xD4B8D4],
        [/XM|Xm_|Sumeru|SXT|SXTF|CWL|Nvshen|CWMY|CWDJ|CWXJ|CWZ|40Boss/i,  0xC8E8C8],
        [/FD|Fd_|FDC|Fontaine|KPM/i,                                        0xB8E8E8],
        [/NT|Nt_|Ndkl|Natlan|BGC|NXZ|HJC|HSLC|LCGY|ZDL/i,                  0xE8C8B8],
        [/Enka|LXLZ/i,                                                      0xD4D4E8],
        [/Chasm|TKDX/i,                                                      0xD4C8B8],
    ];
    const DEFAULT_REGION_COLOR = 0xD4D4D4;

    // #section state
    const state = {
        manifest: null,
        blocks: new Map(),
        cityEntries: [],
        oceanMesh: null,

        meshCache: new Map(),
        textureCache: new Map(),
        failedUrls: new Set(),
        loading: new Set(),

        overrides: new Map(),
        originals: new Map(),
        meshIds: new WeakMap(),

        debug: false,
        show: { hlod: true, terrain: true, water: true, city: true },

        walk: false,
        walkSpeed: WALK_DEFAULT_MULT,
        pointerLocked: false,
        move: { forward: false, backward: false, left: false, right: false, up: false, down: false },

        stats: { hlod: [0,0,0], terrain: [0,0,0], city: [0,0,0], water: 0, activeBlocks: 0 },
        lastLodUpdate: 0,
        lodUpdateInProgress: false,
    };

    // #section loader queue
    const loaderQueue = {
        pending: [],
        active: 0,

        enqueue(taskFn) {
            return new Promise((resolve, reject) => {
                this.pending.push({ taskFn, resolve, reject });
                this._flush();
            });
        },

        _flush() {
            while (this.active < MAX_ASSET_LOAD_COUNT && this.pending.length > 0) {
                const job = this.pending.shift();
                this.active++;
                this._run(job);
            }
        },

        async _run({ taskFn, resolve, reject }) {
            let lastError;
            for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
                try {
                    const result = await taskFn();
                    resolve(result);
                    this.active--;
                    this._flush();
                    return;
                } catch (err) {
                    lastError = err;
                    if (attempt < MAX_RETRIES) {
                        await new Promise(r => setTimeout(r, 300 * (attempt + 1)));
                    }
                }
            }
            reject(lastError);
            this.active--;
            this._flush();
        },
    };

    // #section scene setup

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0xadd8e6, 15000, 40000);

    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 1, 100000);
    camera.position.set(6000, 8000, 4000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const sun = new THREE.DirectionalLight(0xfff4e6, 1.5);
    sun.position.set(1, 2, 1);
    scene.add(sun);

    const orbitControls = new OrbitControls(camera, renderer.domElement);
    orbitControls.enableDamping = true;
    orbitControls.dampingFactor = 0.05;
    orbitControls.maxDistance = 50000;
    orbitControls.minDistance = 100;
    const yaw = -Math.PI / 2;
    const pitch = -Math.PI / 3;
    const dist = 10000;
    orbitControls.target.set(
        camera.position.x + dist * Math.sin(yaw) * Math.cos(pitch),
        camera.position.y + dist * Math.sin(pitch),
        camera.position.z - dist * Math.cos(yaw) * Math.cos(pitch)
    );
    orbitControls.update();

    const pointerControls = new PointerLockControls(camera, document.body);
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    let prevTime = performance.now();

    const objLoader = new OBJLoader();
    const gltfLoader = new GLTFLoader();

    const textureLoader = new THREE.TextureLoader();
    async function fetchTexture(url) {
        return loaderQueue.enqueue(() => {
            return new Promise((resolve, reject) => {
                textureLoader.load(
                    url,
                    (texture) => {
                        texture.colorSpace = THREE.SRGBColorSpace;
                        resolve(texture);
                    },
                    undefined,
                    reject
                );
            });
        });
    }

    const mondstadtTex = new THREE.Texture();
    mondstadtTex.colorSpace = THREE.SRGBColorSpace;
    fetchTexture('/Stages_Texture_Area_Mengde_City_HLOD_Combined_Diffuse.png')
        .then(tex => { mondstadtTex.image = tex.image; mondstadtTex.needsUpdate = true; })
        .catch(() => console.log('Mondstadt texture unavailable'));

    // #section materials

    function makeMaterial(type, lod, texture) {
        if (state.debug) {
            const key = type === 'water' ? 'water' : `${type}_${lod}`;
            return new THREE.MeshStandardMaterial({
                color: DEBUG_COLORS[key] || 0x888888,
                side: THREE.DoubleSide,
            });
        }
        if (type === 'water') {
            return new THREE.MeshStandardMaterial({
                color: 0x1a5f7a, side: THREE.DoubleSide,
                metalness: 0.3, roughness: 0.1,
                transparent: true, opacity: 0.95, depthWrite: false,
                polygonOffset: true, polygonOffsetFactor: -2, polygonOffsetUnits: -2,
            });
        }
        if (texture) {
            return new THREE.MeshStandardMaterial({ map: texture, side: THREE.DoubleSide });
        }
        return new THREE.MeshStandardMaterial({ color: 0x3d5a3d, side: THREE.DoubleSide });
    }

    function makeCityMaterial(name, lod) {
        if (state.debug) {
            return new THREE.MeshStandardMaterial({
                color: DEBUG_COLORS[`city_${lod}`] || 0xff00ff,
                side: THREE.DoubleSide,
            });
        }
        const region = getRegion(name);
        if (region.isMondstadt) {
            return new THREE.MeshStandardMaterial({
                map: mondstadtTex, side: THREE.DoubleSide, roughness: 0.8, metalness: 0.1,
            });
        }
        return new THREE.MeshStandardMaterial({
            color: region.color, side: THREE.DoubleSide, roughness: 0.8, metalness: 0.1,
        });
    }

    function getRegion(name) {
        for (const [pattern, color, isMondstadt] of REGION_PATTERNS) {
            if (pattern.test(name)) return { color, isMondstadt: !!isMondstadt };
        }
        return { color: DEFAULT_REGION_COLOR, isMondstadt: false };
    }

    // #section uv generation
    function generatePlanarUVs(geometry) {
        const pos = geometry.attributes.position;
        const uvs = new Float32Array(pos.count * 2);
        geometry.computeBoundingBox();
        const { min, max } = geometry.boundingBox;
        const w = max.x - min.x || 1;
        const d = max.z - min.z || 1;
        for (let i = 0; i < pos.count; i++) {
            uvs[i * 2]     = 1 - (pos.getX(i) - min.x) / w;
            uvs[i * 2 + 1] = (pos.getZ(i) - min.z) / d;
        }
        geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
    }

    function generateTerrainUVs(geometry, localPos) {
        const pos = geometry.attributes.position;
        const uvs = new Float32Array(pos.count * 2);
        for (let i = 0; i < pos.count; i++) {
            uvs[i * 2]     = 1 - (localPos.x + pos.getX(i)) / BLOCK_SIZE;
            uvs[i * 2 + 1] = (localPos.z + pos.getZ(i)) / BLOCK_SIZE;
        }
        geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
    }

    // #section texture loading
    async function loadTexture(bx, bz) {
        const key = `${bx}_${bz}`;
        if (state.textureCache.has(key)) return state.textureCache.get(key);

        const url = GAME_DATA + `/textures/BigWorldTerrain_${bx}_${bz}.bin_BaseMap.png`;
        if (state.failedUrls.has(url)) return null;

        try {
            const tex = await fetchTexture(url);
            state.textureCache.set(key, tex);
            return tex;
        } catch {
            state.failedUrls.add(url);
            return null;
        }
    }

    // #section mesh id & position overrides
    function meshId(type, bx, bz, filename, localPos, entryName) {
        if (type === 'city')  return `city_${(entryName || 'unknown').replace(/\W/g, '_')}_${filename}`;
        if (type === 'water') return 'water_ocean';
        const p = localPos ? `_${localPos.x}_${localPos.y}_${localPos.z}` : '';
        return `${type}_${bx}_${bz}_${filename}${p}`;
    }

    function registerMesh(mesh, id, pos) {
        state.meshIds.set(mesh, id);
        state.originals.set(id, { x: pos.x, y: pos.y, z: pos.z });

        let foundOverride = null;
        for (const [key, value] of state.overrides.entries()) {
            if (id.includes(key)) {
                foundOverride = value;
                break;
            }
        }
        if (foundOverride) {
            mesh.position.set(foundOverride.x, foundOverride.y, foundOverride.z);
        } else {
            const hasReal = Math.abs(pos.x) > 0.01 || Math.abs(pos.y) > 0.01 || Math.abs(pos.z) > 0.01;
            if (hasReal) mesh.position.set(pos.x, pos.y, pos.z);
        }
    }

    async function loadOverrides() {
        try {
            const resp = await fetch(BASE + '/overrides.json?t=' + Date.now());
            if (!resp.ok) return;
            const data = await resp.json();
            for (const [id, pos] of Object.entries(data)) state.overrides.set(id, pos);
        } catch (e) { 
            console.error('Failed to load overrides:', e);
        }
    }

    function exportOverrides() {
        const obj = Object.fromEntries(state.overrides);
        const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json' });
        const a = Object.assign(document.createElement('a'), { href: URL.createObjectURL(blob), download: 'overrides.json' });
        a.click();
        URL.revokeObjectURL(a.href);
    }

    // #section lod helpers
    function blockCenter(bx, bz) {
        return new THREE.Vector3(-bx * BLOCK_SIZE + HALF_BLOCK, 0, bz * BLOCK_SIZE + HALF_BLOCK);
    }

    function wantedLods(distance) {
        let hlod;
        if (distance < HLOD_THRESHOLDS[0])      hlod = 0;
        else if (distance < HLOD_THRESHOLDS[1])  hlod = 1;
        else                                      hlod = 2;
        return { hlod, terrain: distance < TERRAIN_THRESHOLD ? 0 : null };
    }

    function bestAvailableLod(lodArrays, wanted) {
        for (let l = wanted; l <= 2; l++) {
            if (lodArrays[l] && lodArrays[l].length > 0) return l;
        }
        return null;
    }

    function extractLod(filename) {
        const m = filename.match(/Lod(\d)/);
        return m ? parseInt(m[1]) : 0;
    }

    // #section mesh loading
    const PLACEHOLDER_COLOR = 0x8fbc8f;

    async function loadBlockMesh(filename, type, bx, bz, localPos, noTexture) {
        if (state.meshCache.has(filename)) {
            const clone = state.meshCache.get(filename).clone();
            // Reset position before applying override or calculated position
            clone.position.set(0, 0, 0);
            
            if (state.debug) {
                const lod = extractLod(filename);
                const mat = makeMaterial(type, lod);
                clone.traverse(c => { if (c.isMesh) c.material = mat; });
            }
            
            // Recalculate position (don't use cached position)
            const box = new THREE.Box3().setFromObject(clone);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const tx = -bx;
            
            let calculatedPos;
            if (type === 'hlod') {
                calculatedPos = new THREE.Vector3(tx * BLOCK_SIZE + HALF_BLOCK - center.x, 0, bz * BLOCK_SIZE + HALF_BLOCK - center.z);
            } else if (localPos) {
                calculatedPos = new THREE.Vector3(tx * BLOCK_SIZE + localPos.x, localPos.y, bz * BLOCK_SIZE + localPos.z);
            } else {
                calculatedPos = new THREE.Vector3(0, 0, 0);
            }
            
            const id = meshId(type, bx, bz, filename, localPos);
            registerMesh(clone, id, calculatedPos);
            return clone;
        }

        if (state.loading.has(filename)) return null;
        const endpoint = type === 'hlod' ? '/hlod/' : '/terrain/';
        const url = GAME_DATA + endpoint + filename;
        if (state.failedUrls.has(url)) return null;

        state.loading.add(filename);

        try {
            const obj = await loaderQueue.enqueue(() => new Promise((resolve, reject) => {
                objLoader.load(url, resolve, undefined, reject);
            }));

            obj.traverse(c => {
                if (!c.isMesh || !c.geometry) return;
                if (type === 'terrain' && localPos) generateTerrainUVs(c.geometry, localPos);
                else generatePlanarUVs(c.geometry);
            });

            const lod = extractLod(filename);

            const sharedMat = state.debug
                ? makeMaterial(type, lod)
                : new THREE.MeshStandardMaterial({ color: PLACEHOLDER_COLOR, side: THREE.DoubleSide });
            obj.traverse(c => { if (c.isMesh) c.material = sharedMat; });

            const box = new THREE.Box3().setFromObject(obj);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const tx = -bx;

            if (type === 'hlod') {
                obj.position.set(tx * BLOCK_SIZE + HALF_BLOCK - center.x, 0, bz * BLOCK_SIZE + HALF_BLOCK - center.z);
            } else if (localPos) {
                obj.position.set(tx * BLOCK_SIZE + localPos.x, localPos.y, bz * BLOCK_SIZE + localPos.z);
            }

            state.meshCache.set(filename, obj);
            state.loading.delete(filename);
            state.stats[type][lod]++;

            if (!state.debug && !noTexture) {
                loadTexture(bx, bz).then(tex => {
                    if (tex) {
                        sharedMat.map = tex;
                        sharedMat.color.set(0xffffff);
                        sharedMat.needsUpdate = true;
                    }
                });
            }

            const clone = obj.clone();
            clone.traverse(c => { if (c.isMesh) c.material = sharedMat; });

            const id = meshId(type, bx, bz, filename, localPos);
            registerMesh(clone, id, clone.position.clone());
            return clone;
        } catch {
            state.failedUrls.add(url);
            state.loading.delete(filename);
            return null;
        }
    }

    async function loadCityMesh(entry, lod) {
        const filename = entry.lods[lod];
        if (!filename) return null;

        const cacheKey = `city_${filename}`;
        if (state.meshCache.has(cacheKey)) {
            const clone = state.meshCache.get(cacheKey).clone();
            if (state.debug) {
                const mat = makeCityMaterial(entry.name, lod);
                clone.traverse(c => { if (c.isMesh) c.material = mat; });
            }
            const id = meshId('city', 0, 0, filename, null, entry.name);
            registerMesh(clone, id, clone.position.clone());
            return clone;
        }

        if (state.loading.has(filename)) return null;
        const url = GAME_DATA + '/hlod_all/' + filename;
        if (state.failedUrls.has(url)) return null;

        state.loading.add(filename);

        try {
            const obj = await loaderQueue.enqueue(() => new Promise((resolve, reject) => {
                objLoader.load(url, resolve, undefined, reject);
            }));

            const mat = makeCityMaterial(entry.name, lod);
            obj.traverse(c => { if (c.isMesh) c.material = mat; });

            if (entry.position) {
                obj.position.set(-entry.position.x + CITY_SOUTH_OFFSET, entry.position.y, entry.position.z);
            }

            state.meshCache.set(cacheKey, obj);
            state.loading.delete(filename);

            const clone = obj.clone();
            const id = meshId('city', 0, 0, filename, null, entry.name);
            registerMesh(clone, id, clone.position.clone());
            return clone;
        } catch {
            state.failedUrls.add(url);
            state.loading.delete(filename);
            return null;
        }
    }

    async function loadOcean() {
        if (state.oceanMesh || !state.show.water) return;
        const url = BASE + '/ocean.glb';
        if (state.failedUrls.has(url) || state.loading.has('ocean.glb')) return;

        state.loading.add('ocean.glb');

        try {
            const gltf = await loaderQueue.enqueue(() => new Promise((resolve, reject) => {
                gltfLoader.load(url, resolve, undefined, reject);
            }));

            const obj = gltf.scene;
            const mat = makeMaterial('water', 0);
            obj.traverse(c => { if (c.isMesh) c.material = mat; });
            obj.position.set(BLOCK_SIZE, 210, 0);

            const id = meshId('water', 0, 0, 'ocean');
            registerMesh(obj, id, obj.position.clone());

            scene.add(obj);
            state.oceanMesh = obj;
            state.loading.delete('ocean.glb');
            state.stats.water = 1;
            return obj;
        } catch {
            state.failedUrls.add(url);
            state.loading.delete('ocean.glb');
            return null;
        }
    }

    // #section block lod management
    function initBlock(key, bx, bz, manifest) {
        if (state.blocks.has(key)) return state.blocks.get(key);

        const noTexture = ['hlod', 'terrain'].some(t =>
            manifest[t] && manifest[t][key] && manifest[t][key].no_texture
        );
        const block = {
            bx, bz,
            center: blockCenter(bx, bz),
            hlod: { 0: [], 1: [], 2: [] },
            terrain: { 0: [], 1: [], 2: [] },
            meshes: [],
            activeHlod: null,
            activeTerrain: null,
            noTexture,
        };

        for (const type of ['hlod', 'terrain']) {
            const data = manifest[type] && manifest[type][key];
            if (!data || !data.lods) continue;
            for (const [lod, meshes] of Object.entries(data.lods)) {
                block[type][parseInt(lod)] = meshes;
            }
        }

        state.blocks.set(key, block);
        return block;
    }

    async function updateBlock(block) {
        const dist = camera.position.distanceTo(block.center);
        const want = wantedLods(dist);

        const hlodLod = (want.hlod !== null && state.show.hlod)
            ? bestAvailableLod(block.hlod, want.hlod) : null;
        const terrainLod = (want.terrain !== null && state.show.terrain)
            ? bestAvailableLod(block.terrain, want.terrain) : null;

        const hlodKey = hlodLod !== null ? `hlod_${hlodLod}` : null;
        const terrainKey = terrainLod !== null ? `terrain_${terrainLod}` : null;

        if (block.activeHlod === hlodKey && block.activeTerrain === terrainKey) return;

        // Remove old meshes immediately, then stream new ones in as they load
        for (const m of block.meshes) scene.remove(m);
        block.meshes = [];
        block.activeHlod = hlodKey;
        block.activeTerrain = terrainKey;

        const addMesh = async (promise) => {
            const m = await promise;
            if (m && block.activeHlod === hlodKey && block.activeTerrain === terrainKey) {
                scene.add(m);
                block.meshes.push(m);
            }
        };

        const loads = [];
        // Load hlod first (big stage meshes) so they appear immediately
        if (hlodLod !== null) {
            for (const data of block.hlod[hlodLod]) {
                loads.push(addMesh(loadBlockMesh(data.file, 'hlod', block.bx, block.bz, data.position, block.noTexture)));
            }
        }
        if (terrainLod !== null) {
            for (const data of block.terrain[terrainLod]) {
                loads.push(addMesh(loadBlockMesh(data.file, 'terrain', block.bx, block.bz, data.position, block.noTexture)));
            }
        }

        await Promise.all(loads);
    }

    // #section city lod management
    function initCityEntries(allHlodManifest) {
        const entries = Object.values(allHlodManifest).flat();
        const valid = entries.filter(e => e.position && (e.lods['0'] || e.lods['1'] || e.lods['2']));

        for (const entry of valid) {
            state.cityEntries.push({
                entry,
                worldPos: new THREE.Vector3(-entry.position.x + CITY_SOUTH_OFFSET, entry.position.y, entry.position.z),
                activeLod: null,
                mesh: null,
            });
        }
        console.log(`City HLOD: ${state.cityEntries.length} entries`);
    }

    async function updateCityEntry(ce) {
        if (ce.deleted) return;
        if (!state.show.city) {
            if (ce.mesh) { scene.remove(ce.mesh); ce.mesh = null; ce.activeLod = null; }
            return;
        }

        const availLod = bestAvailableLod(
            { 0: ce.entry.lods['0'] ? [1] : [], 1: ce.entry.lods['1'] ? [1] : [], 2: ce.entry.lods['2'] ? [1] : [] },
            0
        );
        if (availLod === null || ce.activeLod === availLod) return;

        const newMesh = await loadCityMesh(ce.entry, availLod);
        if (!newMesh) return;

        if (ce.mesh) {
            scene.remove(ce.mesh);
            if (ce.activeLod !== null) state.stats.city[ce.activeLod] = Math.max(0, state.stats.city[ce.activeLod] - 1);
        }

        scene.add(newMesh);
        ce.mesh = newMesh;
        ce.activeLod = availLod;
        state.stats.city[availLod]++;
    }

    // #section refresh helpers
    function clearBlocks() {
        state.meshCache.clear();
        state.stats.hlod = [0, 0, 0];
        state.stats.terrain = [0, 0, 0];
        for (const block of state.blocks.values()) {
            for (const m of block.meshes) scene.remove(m);
            block.meshes = [];
            block.activeHlod = null;
            block.activeTerrain = null;
        }
    }

    function clearCity() {
        for (const ce of state.cityEntries) {
            if (ce.mesh) { scene.remove(ce.mesh); ce.mesh = null; }
            ce.activeLod = null;
        }
        for (const key of [...state.meshCache.keys()]) {
            if (key.startsWith('city_')) state.meshCache.delete(key);
        }
        state.stats.city = [0, 0, 0];
    }

    async function refreshWater() {
        if (state.oceanMesh) { scene.remove(state.oceanMesh); state.oceanMesh = null; state.stats.water = 0; }
        if (state.show.water) await loadOcean();
    }

    // #section walk mode
    function toggleWalk() {
        state.walk = !state.walk;
        orbitControls.enabled = !state.walk;
        if (state.walk) {
            pointerControls.lock();
            state.walkSpeed = WALK_DEFAULT_MULT;
        } else {
            pointerControls.unlock();
        }
    }

    function adjustWalkSpeed(increase) {
        const logMin = Math.log(WALK_MIN_MULT);
        const logMax = Math.log(WALK_MAX_MULT);
        const step = (logMax - logMin) * 0.05;
        const cur = Math.log(state.walkSpeed);
        state.walkSpeed = Math.exp(Math.max(logMin, Math.min(logMax, cur + (increase ? step : -step))));
    }

    function updateWalkMovement() {
        if (!state.walk || !pointerControls.isLocked) return;

        const now = performance.now();
        const delta = (now - prevTime) / 1000;
        prevTime = now;

        const speed = WALK_BASE_SPEED * state.walkSpeed;
        const m = state.move;

        velocity.x -= velocity.x * 10 * delta;
        velocity.z -= velocity.z * 10 * delta;
        velocity.y -= velocity.y * 10 * delta;

        direction.set(
            Number(m.right) - Number(m.left),
            Number(m.up) - Number(m.down),
            Number(m.forward) - Number(m.backward),
        ).normalize();

        if (m.forward || m.backward) velocity.z -= direction.z * speed * delta;
        if (m.left || m.right)       velocity.x -= direction.x * speed * delta;
        if (m.up || m.down)          velocity.y += direction.y * speed * delta;

        pointerControls.moveRight(-velocity.x * delta);
        pointerControls.moveForward(-velocity.z * delta);
        camera.position.y = Math.max(WALK_HEIGHT, camera.position.y + velocity.y * delta);
    }

    // #section input
    const WALK_KEYS = {
        KeyW: 'forward', KeyS: 'backward', KeyA: 'left', KeyD: 'right',
        Space: 'up', ShiftLeft: 'down', ShiftRight: 'down',
    };

    const TOGGLE_HANDLERS = {
        d() { state.debug = !state.debug; clearBlocks(); refreshWater(); clearCity(); },
        h() { state.show.hlod = !state.show.hlod; clearBlocks(); },
        t() { state.show.terrain = !state.show.terrain; clearBlocks(); },
        w() { state.show.water = !state.show.water; refreshWater(); },
        c() { state.show.city = !state.show.city; clearCity(); },
    };

    addEventListener('keydown', e => {
        if (state.walk) {
            if (WALK_KEYS[e.code]) state.move[WALK_KEYS[e.code]] = true;
            if (e.code === 'ArrowUp')   adjustWalkSpeed(true);
            if (e.code === 'ArrowDown') adjustWalkSpeed(false);
        } else {
            const handler = TOGGLE_HANDLERS[e.key.toLowerCase()];
            if (handler) handler();
        }
        if (e.key.toLowerCase() === 'f') toggleWalk();
        if (e.key === 'Escape' && state.walk) {
            state.walk = false;
            orbitControls.enabled = true;
        }
    });

    addEventListener('keyup', e => {
        if (WALK_KEYS[e.code]) state.move[WALK_KEYS[e.code]] = false;
    });

    function getMeshId(mesh) {
        // First try to get ID from the mesh itself
        let current = mesh;
        while (current) {
            if (state.meshIds.has(current)) {
                return state.meshIds.get(current);
            }
            current = current.parent;
        }
        // Fallback to mesh name
        return mesh.name || 'unnamed';
    }

    renderer.domElement.addEventListener('mousedown', (event) => {
        if (state.walk && !pointerControls.isLocked) {
            pointerControls.lock();
        }
    });

    addEventListener('resize', () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });

    // #section hud
    const hud = document.getElementById('hud');

    function updateHud() {
        const { x, y, z } = camera.position;
        const s = state.stats;
        const sh = state.show;

        const toggle = (key, label, on) =>
            `<div>[${key}] ${label}: <span class="${on ? 'on' : 'off'}">${on ? 'ON' : 'OFF'}</span></div>`;

        let html = `
            <div class="header">
                <a href="https://github.com/flatypus/hoyomap" target="_blank">
                    <img src="https://github.githubassets.com/favicons/favicon.svg" alt="GitHub">
                    <h1>HoyoMap</h1>
                </a>
            </div>
            <div><span class="l">Camera:</span> <span class="v">${x|0}, ${y|0}, ${z|0}</span></div>
            <div class="section"><span class="l">HLOD:</span></div>
            <div class="row"><span class="l">L0:</span> <span class="v">${s.hlod[0]}</span> <span class="l">L1:</span> <span class="v">${s.hlod[1]}</span> <span class="l">L2:</span> <span class="v">${s.hlod[2]}</span></div>
            <div class="section"><span class="l">Terrain:</span></div>
            <div class="row"><span class="l">L0:</span> <span class="v">${s.terrain[0]}</span> <span class="l">L1:</span> <span class="v">${s.terrain[1]}</span> <span class="l">L2:</span> <span class="v">${s.terrain[2]}</span></div>
            <div class="section"><span class="l">City:</span></div>
            <div class="row"><span class="l">L0:</span> <span class="v">${s.city[0]}</span> <span class="l">L1:</span> <span class="v">${s.city[1]}</span> <span class="l">L2:</span> <span class="v">${s.city[2]}</span></div>
            <div class="section"><span class="l">Water:</span> <span class="v">${s.water}</span> | <span class="l">Blocks:</span> <span class="v">${s.activeBlocks}</span> | <span class="l">Loading:</span> <span class="o">${loaderQueue.active}/${MAX_ASSET_LOAD_COUNT}</span> <span class="l">Queued:</span> <span class="o">${loaderQueue.pending.length}</span></div>
            <div class="toggles">
                ${toggle('F', 'Walk', state.walk)}
                ${toggle('D', 'Debug', state.debug)}
                ${toggle('H', 'HLOD', sh.hlod)}
                ${toggle('T', 'Terrain', sh.terrain)}
                ${toggle('W', 'Water', sh.water)}
                ${toggle('C', 'City', sh.city)}
            </div>`;

        if (state.walk) {
            html += `
            <div class="walk-panel">
                <strong>WALK MODE</strong> | Speed: <span class="on">${state.walkSpeed.toFixed(1)}x</span> (${(WALK_BASE_SPEED * state.walkSpeed)|0} u/s)<br>
                <span class="l">[WASD] Move [Up/Down] Speed [Space/Shift] Fly [ESC] Exit</span>
                ${pointerControls.isLocked ? '' : '<div style="color:#ffa500">Click to lock mouse</div>'}
            </div>`;
        }

        if (state.debug) {
            html += `<div class="legend">
                <span style="color:#ff0000">H0</span> <span style="color:#ff6600">H1</span> <span style="color:#ffcc00">H2</span>
                <span style="color:#00ff00">T0</span> <span style="color:#00ffff">T1</span> <span style="color:#0066ff">T2</span>
                <span style="color:#ff00ff">C0</span> <span style="color:#cc00cc">C1</span> <span style="color:#990099">C2</span>
            </div>`;
        }

        hud.innerHTML = html;
    }

    // #section lod update loop
    async function updateLods() {
        const now = performance.now();
        if (now - state.lastLodUpdate < LOD_UPDATE_MS) return;
        if (state.lodUpdateInProgress) return;
        state.lodUpdateInProgress = true;
        state.lastLodUpdate = now;

        try {
            state.stats.activeBlocks = 0;
            
            // sort by distance
            const blocks = [...state.blocks.values()];
            const camPos = camera.position;
            blocks.sort((a, b) => camPos.distanceToSquared(a.center) - camPos.distanceToSquared(b.center));

            await Promise.all(blocks.map(async block => {
                await updateBlock(block);
                if (block.meshes.length > 0) state.stats.activeBlocks++;
            }));

            await Promise.all(state.cityEntries.map(ce => updateCityEntry(ce)));

            updateHud();
        } finally {
            state.lodUpdateInProgress = false;
        }
    }

    // #section init & animate
    async function init() {
        updateHud();
        
        fetchTexture('/skybox.png').then(tex => {
            const pmrem = new THREE.PMREMGenerator(renderer);
            const env = pmrem.fromEquirectangular(tex).texture;
            scene.environment = env;
            scene.background = env;
            pmrem.dispose();
        }).catch(() => console.log('No skybox available'));

        const [manifestResp, allHlodResp] = await Promise.all([
            fetch(BASE + '/manifests/android_manifest.json'),
            fetch(BASE + '/manifests/all_hlod_manifest.json'),
        ]);
        state.manifest = await manifestResp.json();
        const allHlod = await allHlodResp.json();

        updateHud();
        await loadOverrides();

        updateHud();
        const allKeys = new Set([
            ...Object.keys(state.manifest.hlod || {}),
            ...Object.keys(state.manifest.terrain || {}),
        ]);
        for (const key of allKeys) {
            const [bx, bz] = key.split('_').map(Number);
            initBlock(key, bx, bz, state.manifest);
        }

        updateHud();
        await loadOcean();

        updateHud();
        initCityEntries(allHlod);

        updateHud();
        animate();
    }

    function animate() {
        requestAnimationFrame(animate);
        if (state.walk && pointerControls.isLocked) {
            updateWalkMovement();
        } else {
            orbitControls.update();
        }
        updateLods();
        renderer.render(scene, camera);
    }

    init();
    </script>
</body>
</html>
